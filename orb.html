<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organic Voice Orb</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #0a0a0a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        #canvas {
            position: relative;
            z-index: 1;
            pointer-events: none;
        }

        .controls {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-align: center;
            pointer-events: auto;
        }

        button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0 5px;
            position: relative;
            z-index: 101;
            pointer-events: auto;
        }

        button:hover {
            background: #1d4ed8;
            transform: translateY(-2px);
        }

        button:disabled {
            background: #4b5563;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            color: #9ca3af;
            margin-top: 10px;
            font-size: 14px;
        }

        .permission-needed {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            max-width: 400px;
            padding: 20px;
            z-index: 100;
            pointer-events: auto;
        }

        .permission-needed h2 {
            color: #2563eb;
            margin-bottom: 20px;
        }

        .permission-needed p {
            color: #9ca3af;
            margin-bottom: 30px;
        }

        .error {
            color: #ef4444;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="permission-needed" id="permissionPrompt">
        <h2>Voice Orb Visualizer</h2>
        <p>Click the button below to enable microphone access and see the organic voice orb respond to your voice in real-time.</p>
        <button id="startBtn">Enable Microphone</button>
    </div>

    <div class="controls" id="controls" style="display: none;">
        <button id="toggleBtn">Stop Listening</button>
        <button id="testBtn">Test Mode</button>
        <button id="assistantBtn">Assistant Audio Mode</button>
        <button id="playTestBtn" style="display: none;">Play Test Audio</button>
        <div class="status" id="status">Listening...</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const toggleBtn = document.getElementById('toggleBtn');
        const testBtn = document.getElementById('testBtn');
        const assistantBtn = document.getElementById('assistantBtn');
        const playTestBtn = document.getElementById('playTestBtn');
        const status = document.getElementById('status');
        const permissionPrompt = document.getElementById('permissionPrompt');
        const controls = document.getElementById('controls');

        // Artelia brand blue
        const BRAND_BLUE = '#2563eb';
        
        // Animation variables
        let audioContext;
        let analyser;
        let microphone;
        let mediaStream;
        let isListening = false;
        let isTestMode = false;
        let animationId;
        
        // Assistant audio variables
        let assistantAudioContext;
        let assistantAnalyser;
        let assistantAudioElement;
        let isAssistantMode = false;
        let assistantAudioBuffer = null;
        
        // Orb properties
        let orbX, orbY;
        let baseRadius = 100;
        let time = 0;
        let smoothedVolume = 0;
        let targetVolume = 0;
        let targetX, targetY;
        let currentX, currentY;
        
        // Adaptive calibration system
        let isCalibrating = false;
        let calibrationSamples = [];
        let calibrationStartTime = 0;
        const CALIBRATION_DURATION = 3000; // 3 seconds
        let baselineNoise = 0.02; // Default baseline
        let dynamicSensitivityThreshold = 0.08;
        let dynamicLoudThreshold = 0.4;
        let dynamicVeryLoudThreshold = 0.7;
        
        // Volume adaptation
        let volumeHistory = [];
        const VOLUME_HISTORY_SIZE = 100;
        let adaptiveGain = 1.0;
        
        // Enhanced fading system
        let previousVolumeLevel = 0;
        let fadeMultiplier = 1;
        
        // Debug variables
        let rawVolumeDisplay = 0;
        let smoothedVolumeDisplay = 0;
        let activeForces = 0;
        
        // Easing variables for smooth return to circle
        let lastAudioTime = 0;
        const AUDIO_FADE_DURATION = 1200;
        
        // Internal force system
        let internalForces = [];
        
        // Noise points for organic shape
        const noisePoints = [];
        const numPoints = 24; // Increased for smoother curves
        
        // Initialize canvas size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            orbX = canvas.width / 2;
            orbY = canvas.height / 2;
            targetX = orbX;
            targetY = orbY;
            currentX = orbX;
            currentY = orbY;
        }
        
        // Initialize noise points
        function initNoisePoints() {
            noisePoints.length = 0; // Clear existing points
            for (let i = 0; i < numPoints; i++) {
                noisePoints.push({
                    angle: (i / numPoints) * Math.PI * 2,
                    speed: 0.001 + Math.random() * 0.002,
                    amplitude: 0.3 + Math.random() * 0.3,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }
        
        // Initialize audio
        async function initAudio() {
            try {
                // First, cleanup any existing audio setup
                if (audioContext || mediaStream) {
                    console.log('Cleaning up existing audio setup before initializing new one');
                    stopAudio();
                    // Wait a moment for cleanup to complete
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                console.log('Requesting microphone access...');
                
                // Request microphone permission with fresh request
                mediaStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    } 
                });
                
                console.log('Microphone access granted, creating audio context...');
                
                // Create fresh audio context (let browser choose optimal sample rate)
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Resume audio context if suspended (required by browsers)
                if (audioContext.state === 'suspended') {
                    console.log('Resuming suspended audio context...');
                    await audioContext.resume();
                }
                
                console.log('Audio context state:', audioContext.state);
                console.log('Audio context sample rate:', audioContext.sampleRate);
                
                // Log media stream info
                const audioTracks = mediaStream.getAudioTracks();
                if (audioTracks.length > 0) {
                    const track = audioTracks[0];
                    const settings = track.getSettings();
                    console.log('Media stream sample rate:', settings.sampleRate);
                    console.log('Audio device:', track.label || 'Unknown device');
                }
                
                // Create analyser and microphone source
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(mediaStream);
                
                analyser.fftSize = 512;
                analyser.smoothingTimeConstant = 0.8;
                
                microphone.connect(analyser);
                
                isListening = true;
                isTestMode = false;
                permissionPrompt.style.display = 'none';
                controls.style.display = 'block';
                
                // Start calibration
                startCalibration();
                
                if (!animationId) {
                    animate();
                }
                
                console.log('Audio initialization complete');
                
            } catch (error) {
                console.error('Error accessing microphone:', error);
                status.textContent = `Error: ${error.message}`;
                status.classList.add('error');
                
                // Show fallback test mode
                permissionPrompt.style.display = 'none';
                controls.style.display = 'block';
                toggleBtn.style.display = 'none';
            }
        }
        
        // Start calibration process
        function startCalibration() {
            isCalibrating = true;
            calibrationSamples = [];
            calibrationStartTime = performance.now();
            status.textContent = 'Calibrating... Please stay quiet for 3 seconds';
            toggleBtn.textContent = 'Calibrating...';
            toggleBtn.disabled = true;
        }
        
        // Process calibration
        function processCalibration(volume) {
            if (!isCalibrating) return;
            
            calibrationSamples.push(volume);
            const elapsed = performance.now() - calibrationStartTime;
            
            if (elapsed >= CALIBRATION_DURATION) {
                // Calculate baseline noise from samples
                calibrationSamples.sort((a, b) => a - b);
                const median = calibrationSamples[Math.floor(calibrationSamples.length / 2)];
                const p90 = calibrationSamples[Math.floor(calibrationSamples.length * 0.9)];
                
                baselineNoise = Math.max(0.01, median);
                
                // Set adaptive thresholds based on environment
                dynamicSensitivityThreshold = baselineNoise + 0.03;
                dynamicLoudThreshold = baselineNoise + 0.15;
                dynamicVeryLoudThreshold = baselineNoise + 0.35;
                
                // Calculate adaptive gain to normalize volume range
                const noiseRange = p90 - baselineNoise;
                adaptiveGain = noiseRange > 0.05 ? 0.8 / noiseRange : 2.0;
                adaptiveGain = Math.max(0.5, Math.min(adaptiveGain, 4.0));
                
                isCalibrating = false;
                status.textContent = `Calibrated! Baseline: ${baselineNoise.toFixed(3)}`;
                toggleBtn.textContent = 'Stop Listening';
                toggleBtn.disabled = false;
            } else {
                const remaining = Math.ceil((CALIBRATION_DURATION - elapsed) / 1000);
                status.textContent = `Calibrating... ${remaining}s remaining (stay quiet)`;
            }
        }
        
        // Adaptive volume processing
        function processVolumeAdaptively(rawVolume) {
            // Store volume history for continuous adaptation
            volumeHistory.push(rawVolume);
            if (volumeHistory.length > VOLUME_HISTORY_SIZE) {
                volumeHistory.shift();
            }
            
            // Subtract baseline noise
            let adjustedVolume = Math.max(0, rawVolume - baselineNoise);
            
            // Apply adaptive gain
            adjustedVolume *= adaptiveGain;
            
            // Continuous adaptation: adjust gain based on recent volume distribution
            if (volumeHistory.length >= 50 && !isCalibrating) {
                const recentVolumes = volumeHistory.slice(-50);
                const avgRecent = recentVolumes.reduce((a, b) => a + b, 0) / recentVolumes.length;
                const targetRange = 0.3; // Target average volume
                
                if (avgRecent > 0.05) {
                    const gainAdjustment = targetRange / avgRecent;
                    adaptiveGain += (gainAdjustment - adaptiveGain) * 0.001; // Very slow adaptation
                    adaptiveGain = Math.max(0.5, Math.min(adaptiveGain, 4.0));
                }
            }
            
            return Math.min(adjustedVolume, 1.0);
        }
        
        // Initialize assistant audio mode
        async function initAssistantAudio() {
            try {
                console.log('Initializing assistant audio mode...');
                
                // Cleanup any existing audio setup
                if (audioContext || mediaStream || assistantAudioContext) {
                    stopAudio();
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Create audio context for assistant audio
                assistantAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                if (assistantAudioContext.state === 'suspended') {
                    await assistantAudioContext.resume();
                }
                
                // Create analyser for assistant audio
                assistantAnalyser = assistantAudioContext.createAnalyser();
                assistantAnalyser.fftSize = 512;
                assistantAnalyser.smoothingTimeConstant = 0.8;
                
                // Create audio element for playback
                assistantAudioElement = document.createElement('audio');
                assistantAudioElement.crossOrigin = 'anonymous';
                assistantAudioElement.controls = false;
                
                isAssistantMode = true;
                isListening = false;
                isTestMode = false;
                
                permissionPrompt.style.display = 'none';
                controls.style.display = 'block';
                status.textContent = 'Assistant Audio Mode - Ready for streaming audio';
                toggleBtn.textContent = 'Stop Assistant Mode';
                playTestBtn.style.display = 'inline-block';
                
                if (!animationId) {
                    animate();
                }
                
                console.log('Assistant audio mode initialized');
                
            } catch (error) {
                console.error('Error initializing assistant audio:', error);
                status.textContent = `Assistant Audio Error: ${error.message}`;
                status.classList.add('error');
            }
        }
        
        // Connect streaming audio to visualizer
        function connectStreamingAudio(audioElement) {
            if (!assistantAudioContext || !assistantAnalyser) {
                console.error('Assistant audio not initialized');
                return false;
            }
            
            try {
                // Create media element source
                const source = assistantAudioContext.createMediaElementSource(audioElement);
                source.connect(assistantAnalyser);
                source.connect(assistantAudioContext.destination); // Connect to speakers
                
                console.log('Streaming audio connected to visualizer');
                return true;
            } catch (error) {
                console.error('Error connecting streaming audio:', error);
                return false;
            }
        }
        
        // Function to be called by the application with audio data
        function processAssistantAudioStream(audioData) {
            if (!isAssistantMode || !assistantAudioContext) return;
            
            try {
                // Convert audio data to AudioBuffer if needed
                if (audioData instanceof ArrayBuffer) {
                    assistantAudioContext.decodeAudioData(audioData.slice())
                        .then(buffer => {
                            assistantAudioBuffer = buffer;
                            playAssistantAudio(buffer);
                        })
                        .catch(error => {
                            console.error('Error decoding assistant audio:', error);
                        });
                } else if (audioData instanceof AudioBuffer) {
                    assistantAudioBuffer = audioData;
                    playAssistantAudio(audioData);
                } else if (typeof audioData === 'string') {
                    // Handle URL or data URL
                    assistantAudioElement.src = audioData;
                    connectStreamingAudio(assistantAudioElement);
                    assistantAudioElement.play();
                }
            } catch (error) {
                console.error('Error processing assistant audio stream:', error);
            }
        }
        
        // Play assistant audio buffer
        function playAssistantAudio(buffer) {
            if (!assistantAudioContext || !assistantAnalyser) return;
            
            try {
                const source = assistantAudioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(assistantAnalyser);
                source.connect(assistantAudioContext.destination);
                source.start(0);
                
                console.log('Playing assistant audio buffer');
            } catch (error) {
                console.error('Error playing assistant audio:', error);
            }
        }
        
        // Play test audio file
        function playTestAudio() {
            if (!isAssistantMode) {
                console.error('Assistant mode not active');
                return;
            }
            
            try {
                // Use the existing processAssistantAudioStream function with the local audio file
                processAssistantAudioStream('./audio.mp3');
                status.textContent = 'Playing test audio - audio.mp3';
                playTestBtn.textContent = 'Playing...';
                playTestBtn.disabled = true;
                
                // Re-enable button after a delay (estimate 10 seconds for typical audio)
                setTimeout(() => {
                    if (playTestBtn) {
                        playTestBtn.textContent = 'Play Test Audio';
                        playTestBtn.disabled = false;
                        if (isAssistantMode) {
                            status.textContent = 'Assistant Audio Mode - Ready for streaming audio';
                        }
                    }
                }, 10000);
                
            } catch (error) {
                console.error('Error playing test audio:', error);
                status.textContent = `Test Audio Error: ${error.message}`;
                status.classList.add('error');
                playTestBtn.textContent = 'Play Test Audio';
                playTestBtn.disabled = false;
            }
        }
        
        // Test mode with simulated audio
        function startTestMode() {
            isTestMode = true;
            isListening = false;
            permissionPrompt.style.display = 'none';
            controls.style.display = 'block';
            status.textContent = 'Test mode - simulated audio response';
            toggleBtn.textContent = 'Try Microphone';
            
            if (!animationId) {
                animate();
            }
        }
        
        // Get audio volume
        function getVolume() {
            if (isTestMode) {
                // Simulate audio input for test mode
                const testVolume = Math.abs(Math.sin(time * 5)) * 0.3 + Math.random() * 0.1;
                rawVolumeDisplay = testVolume;
                return testVolume;
            }
            
            if (isAssistantMode) {
                // Get volume from assistant audio
                if (!assistantAnalyser) return 0;
                
                const bufferLength = assistantAnalyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                assistantAnalyser.getByteFrequencyData(dataArray);
                
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                
                const rawVolume = Math.min(sum / bufferLength / 255, 1);
                rawVolumeDisplay = rawVolume;
                
                // Process calibration if active
                if (isCalibrating) {
                    processCalibration(rawVolume);
                    return 0;
                }
                
                // Apply adaptive processing
                const adaptedVolume = processVolumeAdaptively(rawVolume);
                
                // Track when we last had significant audio
                if (adaptedVolume > dynamicSensitivityThreshold) {
                    lastAudioTime = performance.now();
                }
                
                return adaptedVolume;
            }
            
            if (!analyser) return 0;
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
            }
            
            const rawVolume = Math.min(sum / bufferLength / 255, 1);
            rawVolumeDisplay = rawVolume;
            
            // Process calibration if active
            if (isCalibrating) {
                processCalibration(rawVolume);
                return 0; // Don't trigger animations during calibration
            }
            
            // Apply adaptive processing
            const adaptedVolume = processVolumeAdaptively(rawVolume);
            
            // Track when we last had significant audio - use dynamic threshold
            if (adaptedVolume > dynamicSensitivityThreshold) {
                lastAudioTime = performance.now();
            }
            
            return adaptedVolume;
        }
        
        // Draw debug information
        function drawDebugInfo() {
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px monospace';
            ctx.textAlign = 'left';
            
            const debugY = 30;
            const lineHeight = 18;
            
            ctx.fillText(`Raw Volume: ${rawVolumeDisplay.toFixed(3)}`, 20, debugY);
            ctx.fillText(`Smoothed Volume: ${smoothedVolumeDisplay.toFixed(3)}`, 20, debugY + lineHeight);
            ctx.fillText(`Baseline Noise: ${baselineNoise.toFixed(3)}`, 20, debugY + lineHeight * 2);
            ctx.fillText(`Adaptive Gain: ${adaptiveGain.toFixed(2)}`, 20, debugY + lineHeight * 3);
            ctx.fillText(`Fade Multiplier: ${fadeMultiplier.toFixed(3)}`, 20, debugY + lineHeight * 4);
            ctx.fillText(`Active Forces: ${activeForces}`, 20, debugY + lineHeight * 5);
            
            // Dynamic thresholds
            ctx.fillText(`Sensitivity: ${dynamicSensitivityThreshold.toFixed(3)}`, 20, debugY + lineHeight * 6);
            ctx.fillText(`Loud: ${dynamicLoudThreshold.toFixed(3)}`, 20, debugY + lineHeight * 7);
            ctx.fillText(`Very Loud: ${dynamicVeryLoudThreshold.toFixed(3)}`, 20, debugY + lineHeight * 8);
            
            // Volume level indicator
            let volumeLevel = "SILENT";
            const effectiveVolume = smoothedVolumeDisplay * fadeMultiplier;
            if (effectiveVolume > dynamicVeryLoudThreshold) volumeLevel = "VERY LOUD";
            else if (effectiveVolume > dynamicLoudThreshold) volumeLevel = "LOUD";
            else if (effectiveVolume > dynamicSensitivityThreshold) volumeLevel = "ACTIVE";
            
            ctx.fillText(`Level: ${volumeLevel}`, 20, debugY + lineHeight * 9);
            
            // Show current mode
            let currentMode = "MICROPHONE";
            if (isTestMode) currentMode = "TEST";
            else if (isAssistantMode) currentMode = "ASSISTANT";
            ctx.fillText(`Mode: ${currentMode}`, 20, debugY + lineHeight * 10);
            
            // Calibration status
            if (isCalibrating) {
                ctx.fillStyle = '#ffaa00';
                ctx.fillText(`CALIBRATING... (${calibrationSamples.length} samples)`, 20, debugY + lineHeight * 11);
                ctx.fillStyle = '#ffffff';
            }
            
            // Visual volume bar with enhanced visibility
            const barWidth = 200;
            const barHeight = 12;
            const barX = 20;
            const barY = debugY + lineHeight * 12;
            
            // Background bar
            ctx.fillStyle = '#333333';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            // Border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
            
            // Volume fill - make it more visible
            const volumeWidth = Math.max(1, effectiveVolume * (barWidth - 4));
            ctx.fillStyle = effectiveVolume > dynamicSensitivityThreshold ? '#2563eb' : '#666666';
            ctx.fillRect(barX + 2, barY + 2, volumeWidth, barHeight - 4);
            
            // Threshold markers - make them taller and more visible
            const markerHeight = 18;
            
            // Sensitivity threshold (red)
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(barX + (dynamicSensitivityThreshold * barWidth), barY - 3, 2, markerHeight);
            
            // Loud threshold (orange)
            ctx.fillStyle = '#ffaa00';
            ctx.fillRect(barX + (dynamicLoudThreshold * barWidth), barY - 3, 2, markerHeight);
            
            // Very loud threshold (magenta)
            ctx.fillStyle = '#ff00ff';
            ctx.fillRect(barX + (dynamicVeryLoudThreshold * barWidth), barY - 3, 2, markerHeight);
            
            // Add threshold labels
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px monospace';
            ctx.fillText('S', barX + (dynamicSensitivityThreshold * barWidth) - 2, barY - 6);
            ctx.fillText('L', barX + (dynamicLoudThreshold * barWidth) - 2, barY - 6);
            ctx.fillText('VL', barX + (dynamicVeryLoudThreshold * barWidth) - 4, barY - 6);
            ctx.font = '14px monospace'; // Reset font
        }
        
        // Easing function for smooth transitions
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }
        
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        // Update internal forces - bubbles/tentacles pushing from inside
        function updateInternalForces() {
            // Remove expired forces
            internalForces = internalForces.filter(force => force.life > 0);
            activeForces = internalForces.length;
            
            // Only create forces if above dynamic sensitivity threshold
            if (smoothedVolume > dynamicSensitivityThreshold) {
                // Create new forces based on audio level
                const creationRate = (smoothedVolume - dynamicSensitivityThreshold) * 0.5;
                if (Math.random() < creationRate) {
                    const newForce = {
                        angle: Math.random() * Math.PI * 2,
                        strength: 10 + (smoothedVolume - dynamicSensitivityThreshold) * 50,
                        life: 1.0,
                        decay: 0.008 + Math.random() * 0.012,
                        speed: 0.3 + Math.random() * 1.0,
                        distance: 0,
                        maxDistance: 20 + (smoothedVolume - dynamicSensitivityThreshold) * 60
                    };
                    internalForces.push(newForce);
                }
            }
            
            // Update existing forces with enhanced fading
            internalForces.forEach(force => {
                // Enhanced decay system - forces decay more gradually
                const baseDecay = smoothedVolume < dynamicSensitivityThreshold ? 2.5 : 1;
                const fadeDecay = (1 - fadeMultiplier) * 2; // Additional decay when fading
                force.life -= force.decay * (baseDecay + fadeDecay);
                force.distance += force.speed;
                force.distance = Math.min(force.distance, force.maxDistance);
                force.angle += 0.005; // Slight rotation
            });
        }
        
        // Calculate force influence at a given angle
        function getForceInfluence(angle) {
            let totalInfluence = 0;
            
            internalForces.forEach(force => {
                // Calculate angular distance
                let angleDiff = Math.abs(angle - force.angle);
                if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;
                
                // Force influence decreases with angular distance
                const angularFalloff = Math.max(0, 1 - (angleDiff / (Math.PI * 0.4)));
                
                // Force influence based on life and distance from center
                const forceAmount = force.strength * force.life * angularFalloff;
                const distanceEffect = Math.sin((force.distance / force.maxDistance) * Math.PI);
                
                totalInfluence += forceAmount * distanceEffect;
            });
            
            return totalInfluence;
        }
        
        // Draw organic orb
        function drawOrb() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Get current volume
            const rawVolume = getVolume();
            
            // Enhanced fading system
            const timeSinceAudio = performance.now() - lastAudioTime;
            const fadeProgress = Math.min(timeSinceAudio / AUDIO_FADE_DURATION, 1);
            const fadeFactor = 1 - easeOutCubic(fadeProgress);
            
            // Apply fade factor to volume for smooth return to circle
            targetVolume = rawVolume * fadeFactor;
            smoothedVolume += (targetVolume - smoothedVolume) * 0.12; // Slightly slower for smoother transitions
            smoothedVolumeDisplay = smoothedVolume;
            
            // Enhanced fade multiplier system
            const currentVolumeLevel = smoothedVolume;
            if (currentVolumeLevel < previousVolumeLevel) {
                // Volume is decreasing - apply gradual fade
                fadeMultiplier *= 0.96; // Gradual fade out
            } else {
                // Volume is increasing or stable - restore quickly
                fadeMultiplier += (1 - fadeMultiplier) * 0.15;
            }
            fadeMultiplier = Math.max(0, Math.min(1, fadeMultiplier));
            previousVolumeLevel = currentVolumeLevel;
            
            // Update internal force system
            updateInternalForces();
            
            // Simple solid fill
            ctx.fillStyle = BRAND_BLUE;
            
            // Enhanced threshold check with fade consideration
            const effectiveVolume = smoothedVolume * fadeMultiplier;
            const hasActiveEffects = effectiveVolume >= dynamicSensitivityThreshold || internalForces.length > 0;
            
            if (!hasActiveEffects) {
                // Smoothly return to center when inactive
                targetX = orbX;
                targetY = orbY;
                currentX += (targetX - currentX) * 0.05;
                currentY += (targetY - currentY) * 0.05;
                
                // Perfect circle when below threshold and no effects
                ctx.beginPath();
                ctx.arc(currentX, currentY, baseRadius, 0, Math.PI * 2);
                ctx.fill();
                
            } else {
                // Different motion types based on effective volume level
                let moveAmount = 0;
                let moveSpeed = 1;
                
                if (effectiveVolume > dynamicVeryLoudThreshold) {
                    // VERY LOUD: More dramatic movement but still controlled
                    const agitation = (effectiveVolume - dynamicVeryLoudThreshold) * 2;
                    moveAmount = agitation * 30;
                    moveSpeed = 2 + agitation * 6;
                    targetX = orbX + Math.sin(time * moveSpeed) * moveAmount + 
                             Math.sin(time * moveSpeed * 1.3) * moveAmount * 0.5;
                    targetY = orbY + Math.cos(time * moveSpeed * 0.8) * moveAmount + 
                             Math.cos(time * moveSpeed * 1.2) * moveAmount * 0.4;
                } else if (effectiveVolume > dynamicLoudThreshold) {
                    // LOUD: Moderate movement like the reference
                    const agitation = (effectiveVolume - dynamicLoudThreshold) * 3;
                    moveAmount = agitation * 20;
                    moveSpeed = 1.5 + agitation * 3;
                    targetX = orbX + Math.sin(time * moveSpeed) * moveAmount;
                    targetY = orbY + Math.cos(time * moveSpeed * 0.75) * moveAmount;
                } else {
                    // ACTIVE: Gentle, controlled movement
                    const adjustedVolume = Math.max(0, effectiveVolume - dynamicSensitivityThreshold);
                    moveAmount = adjustedVolume * 12;
                    moveSpeed = 1.2 + adjustedVolume * 2;
                    targetX = orbX + Math.sin(time * moveSpeed) * moveAmount;
                    targetY = orbY + Math.cos(time * moveSpeed * 0.9) * moveAmount;
                }
                
                // Smooth position transitions with dynamic responsiveness
                const agitation = Math.max(0, effectiveVolume - dynamicSensitivityThreshold);
                const positionSpeed = 0.02 + agitation * agitation * 0.06;
                currentX += (targetX - currentX) * positionSpeed;
                currentY += (targetY - currentY) * positionSpeed;
                
                // Generate blob shape with internal forces pushing outward
                const blobPoints = [];
                
                for (let i = 0; i < numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 2;
                    
                    // Start with base circle
                    let radius = baseRadius;
                    
                    // Get influence from internal forces (with fade applied)
                    const forceInfluence = getForceInfluence(angle) * fadeMultiplier;
                    
                    // Add controlled audio reaction with fade
                    const adjustedVolume = Math.max(0, effectiveVolume - dynamicSensitivityThreshold);
                    const audioAmplitude = adjustedVolume * 40 * fadeMultiplier;
                    
                    // Smoother wave patterns with fade
                    const wave1 = Math.sin(angle * 2 + time * 2) * audioAmplitude;
                    const wave2 = Math.sin(angle * 3 - time * 1.5) * audioAmplitude * 0.6;
                    const wave3 = Math.sin(angle * 1.5 + time * 2.5) * audioAmplitude * 0.4;
                    
                    // Gentle organic variation with fade
                    const organicNoise = (Math.sin(angle * 4 + time * 0.6) * 4 + 
                                        Math.sin(angle * 5 - time * 0.4) * 2) * fadeMultiplier;
                    
                    // Combine effects - all scaled by fade multiplier
                    radius += forceInfluence + wave1 + wave2 + wave3 + organicNoise;
                    
                    // More conservative bounds
                    radius = Math.max(radius, baseRadius * (0.6 + (1 - fadeMultiplier) * 0.4));
                    radius = Math.min(radius, baseRadius * (1 + (1.8 + adjustedVolume * 0.7 - 1) * fadeMultiplier));
                    
                    const x = currentX + Math.cos(angle) * radius;
                    const y = currentY + Math.sin(angle) * radius;
                    
                    blobPoints.push({ x, y });
                }
                
                // Create smooth, pleasant curves
                ctx.beginPath();
                
                // Move to starting point
                ctx.moveTo(
                    (blobPoints[numPoints - 1].x + blobPoints[0].x) / 2,
                    (blobPoints[numPoints - 1].y + blobPoints[0].y) / 2
                );
                
                // Draw smooth curves through all points
                for (let i = 0; i < numPoints; i++) {
                    const current = blobPoints[i];
                    const next = blobPoints[(i + 1) % numPoints];
                    
                    // Use quadratic curves for smooth, pleasant results
                    const midX = (current.x + next.x) / 2;
                    const midY = (current.y + next.y) / 2;
                    
                    ctx.quadraticCurveTo(current.x, current.y, midX, midY);
                }
                
                ctx.closePath();
                ctx.fill();
            }
            
            // Draw debug information
            drawDebugInfo();
            
            time += effectiveVolume > dynamicSensitivityThreshold ? 0.006 : 0.001;
        }
        
        // Animation loop
        function animate() {
            drawOrb();
            animationId = requestAnimationFrame(animate);
        }
        
        // Stop audio and cleanup
        function stopAudio() {
            isListening = false;
            isTestMode = false;
            isAssistantMode = false;
            isCalibrating = false;
            
            // Cleanup audio resources
            if (microphone) {
                try {
                    microphone.disconnect();
                } catch (e) {
                    console.warn('Error disconnecting microphone:', e);
                }
                microphone = null;
            }
            
            if (analyser) {
                analyser = null;
            }
            
            if (mediaStream) {
                try {
                    mediaStream.getTracks().forEach(track => {
                        track.stop();
                        console.log('Stopped track:', track.kind);
                    });
                } catch (e) {
                    console.warn('Error stopping media tracks:', e);
                }
                mediaStream = null;
            }
            
            if (audioContext && audioContext.state !== 'closed') {
                try {
                    audioContext.close();
                    console.log('Audio context closed');
                } catch (e) {
                    console.warn('Error closing audio context:', e);
                }
                audioContext = null;
            }
            
            // Cleanup assistant audio resources
            if (assistantAudioElement) {
                try {
                    assistantAudioElement.pause();
                    assistantAudioElement.src = '';
                } catch (e) {
                    console.warn('Error stopping assistant audio element:', e);
                }
                assistantAudioElement = null;
            }
            
            if (assistantAnalyser) {
                assistantAnalyser = null;
            }
            
            if (assistantAudioContext && assistantAudioContext.state !== 'closed') {
                try {
                    assistantAudioContext.close();
                    console.log('Assistant audio context closed');
                } catch (e) {
                    console.warn('Error closing assistant audio context:', e);
                }
                assistantAudioContext = null;
            }
            
            assistantAudioBuffer = null;
            
            // Reset calibration state
            calibrationSamples = [];
            calibrationStartTime = 0;
            
            // Reset volume states
            rawVolumeDisplay = 0;
            smoothedVolume = 0;
            smoothedVolumeDisplay = 0;
            targetVolume = 0;
            fadeMultiplier = 1;
            previousVolumeLevel = 0;
            
            // Reset forces
            internalForces = [];
            activeForces = 0;
            
            // Update UI
            toggleBtn.textContent = 'Start Listening';
            toggleBtn.disabled = false;
            status.textContent = 'Stopped';
            status.classList.remove('error');
            playTestBtn.style.display = 'none';
        }
        
        // Event listeners
        startBtn.addEventListener('click', initAudio);
        
        testBtn.addEventListener('click', startTestMode);
        
        toggleBtn.addEventListener('click', () => {
            if (isListening || isTestMode || isAssistantMode) {
                stopAudio();
            } else {
                initAudio();
            }
        });
        
        assistantBtn.addEventListener('click', () => {
            if (isAssistantMode) {
                stopAudio();
            } else {
                initAssistantAudio();
            }
        });
        
        playTestBtn.addEventListener('click', () => {
            if (isAssistantMode) {
                playTestAudio();
            }
        });
        
        window.addEventListener('resize', resizeCanvas);
        
        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && audioContext) {
                audioContext.suspend();
            } else if (!document.hidden && audioContext) {
                audioContext.resume();
            }
        });
        
        // Listen for device changes (microphone plugged/unplugged)
        if (navigator.mediaDevices && navigator.mediaDevices.addEventListener) {
            navigator.mediaDevices.addEventListener('devicechange', async () => {
                console.log('Audio device change detected');
                
                // If we're currently listening, reinitialize with new device
                if (isListening && !isTestMode) {
                    console.log('Reinitializing audio due to device change...');
                    status.textContent = 'Device changed, reconnecting...';
                    
                    // Small delay to let device settle
                    setTimeout(async () => {
                        try {
                            await initAudio();
                        } catch (error) {
                            console.error('Failed to reinitialize after device change:', error);
                            status.textContent = 'Failed to reconnect. Click "Start Listening" to retry.';
                            status.classList.add('error');
                        }
                    }, 500);
                }
            });
        }
        
        // Initialize
        resizeCanvas();
        initNoisePoints();
        
        // Start idle animation
        animate();
        
        // Global API for external applications
        window.VoiceOrbVisualizer = {
            // Initialize assistant mode
            initAssistantMode: initAssistantAudio,
            
            // Process streaming audio data
            processAudioStream: processAssistantAudioStream,
            
            // Connect existing audio element
            connectAudio: connectStreamingAudio,
            
            // Play test audio file
            playTestAudio: playTestAudio,
            
            // Check if assistant mode is active
            isAssistantMode: () => isAssistantMode,
            
            // Stop all audio processing
            stop: stopAudio,
            
            // Switch to microphone mode
            switchToMicrophone: initAudio,
            
            // Switch to test mode
            switchToTest: startTestMode
        };
    </script>
</body>
</html>